/**
 * PentestGPT Integration Module for Jaeger AI
 *
 * This module integrates PentestGPT as the core AI brain for intelligent
 * cybersecurity analysis and decision making.
 *
 * Features:
 * - Intelligent target analysis
 * - Smart tool selection
 * - Risk assessment
 * - Attack vector analysis
 * - Vulnerability prioritization
 */

const { spawn, exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const { promisify } = require('util');

const execAsync = promisify(exec);

class PentestGPTIntegration {
    constructor(options = {}) {
        this.config = {
            pentestgptPath: options.pentestgptPath || '/home/terrestrial/Desktop/jaeger-ai/PentestGPT',
            logDir: options.logDir || 'logs/pentestgpt',
            reasoningModel: options.reasoningModel || 'gpt-4o',
            parsingModel: options.parsingModel || 'gpt-4o',
            useAPI: options.useAPI !== false,
            ...options
        };

        this.taskLog = {};
        this.conversationHistory = [];

        // Ensure log directory exists
        this.ensureLogDirectory();
    }

    /**
     * Ensure log directory exists
     */
    ensureLogDirectory() {
        const logPath = path.resolve(this.config.logDir);
        if (!fs.existsSync(logPath)) {
            fs.mkdirSync(logPath, { recursive: true });
        }
    }

    /**
     * Initialize PentestGPT environment
     */
    async initialize() {
        try {
            // Check if PentestGPT is available
            const pentestgptPath = path.resolve(this.config.pentestgptPath);
            if (!fs.existsSync(pentestgptPath)) {
                throw new Error(`PentestGPT not found at: ${pentestgptPath}`);
            }

            // Test Python environment
            const { stdout, stderr } = await execAsync('python3 --version');
            console.log(`‚úÖ Python environment: ${stdout.trim()}`);

            return true;
        } catch (error) {
            console.error('‚ùå Failed to initialize PentestGPT:', error.message);
            return false;
        }
    }

    /**
     * Analyze target using PentestGPT intelligence
     * @param {string} target - Target IP, domain, or URL
     * @param {string} context - Additional context about the target
     * @returns {Promise<Object>} Analysis results
     */
    async analyzeTarget(target, context = '') {
        try {
            console.log(`üß† PentestGPT analyzing target: ${target}`);

            const analysis = {
                target,
                timestamp: new Date().toISOString(),
                targetType: this.classifyTarget(target),
                riskLevel: await this.assessRisk(target),
                recommendedTools: await this.selectTools(target),
                attackVectors: await this.identifyAttackVectors(target),
                prioritizedScans: await this.prioritizeScans(target),
                context: context
            };

            // Store in conversation history
            this.conversationHistory.push({
                type: 'target_analysis',
                timestamp: new Date().toISOString(),
                data: analysis
            });

            return analysis;
        } catch (error) {
            console.error('‚ùå Target analysis failed:', error.message);
            throw error;
        }
    }

    /**
     * Classify target type for intelligent analysis
     * @param {string} target
     * @returns {string} Target classification
     */
    classifyTarget(target) {
        const domain = target.toLowerCase();

        if (/^\d+\.\d+\.\d+\.\d+/.test(target)) {
            return 'ip_address';
        }

        if (domain.includes('.edu') || domain.includes('.ac.')) {
            return 'educational';
        }

        if (domain.includes('.gov') || domain.includes('.go.')) {
            return 'government';
        }

        if (domain.includes('bank') || domain.includes('secure')) {
            return 'financial';
        }

        if (domain.includes('.mil')) {
            return 'military';
        }

        return 'commercial';
    }

    /**
     * Assess risk level of target
     * @param {string} target
     * @returns {Promise<Object>} Risk assessment
     */
    async assessRisk(target) {
        const targetType = this.classifyTarget(target);

        const riskProfiles = {
            'ip_address': { level: 'medium', score: 6 },
            'educational': { level: 'low', score: 4 },
            'government': { level: 'high', score: 8 },
            'financial': { level: 'critical', score: 9 },
            'military': { level: 'critical', score: 10 },
            'commercial': { level: 'medium', score: 5 }
        };

        const baseRisk = riskProfiles[targetType] || { level: 'medium', score: 5 };

        return {
            level: baseRisk.level,
            score: baseRisk.score,
            factors: this.getRiskFactors(targetType),
            recommendations: this.getSecurityRecommendations(targetType)
        };
    }

    /**
     * Get risk factors for target type
     * @param {string} targetType
     * @returns {Array} Risk factors
     */
    getRiskFactors(targetType) {
        const factors = {
            'educational': [
                'Typically less security hardening',
                'Multiple entry points (student portals)',
                'Legacy systems may be present'
            ],
            'government': [
                'High-value target',
                'Strong security measures expected',
                'Legal implications significant'
            ],
            'financial': [
                'Critical data protection required',
                'Regulatory compliance mandatory',
                'Advanced threat protection likely'
            ],
            'commercial': [
                'Variable security posture',
                'Business-critical systems',
                'Potential customer data exposure'
            ]
        };

        return factors[targetType] || ['Standard security considerations'];
    }

    /**
     * Get security recommendations
     * @param {string} targetType
     * @returns {Array} Security recommendations
     */
    getSecurityRecommendations(targetType) {
        const recommendations = {
            'educational': [
                'Focus on web application vulnerabilities',
                'Check for exposed student/faculty databases',
                'Look for unpatched content management systems'
            ],
            'government': [
                'Prioritize passive reconnaissance only',
                'Focus on publicly available information',
                'Ensure legal authorization before any active scanning'
            ],
            'financial': [
                'Minimal active scanning recommended',
                'Focus on SSL/TLS configuration',
                'Check for regulatory compliance indicators'
            ],
            'commercial': [
                'Comprehensive vulnerability assessment',
                'Web application security testing',
                'Network service enumeration'
            ]
        };

        return recommendations[targetType] || ['Follow standard penetration testing methodology'];
    }

    /**
     * Select appropriate tools based on target analysis
     * @param {string} target
     * @returns {Promise<Array>} Recommended tools
     */
    async selectTools(target) {
        const targetType = this.classifyTarget(target);
        const riskAssessment = await this.assessRisk(target);

        const toolSets = {
            'educational': [
                { tool: 'nmap', priority: 'high', params: '-sV -sC' },
                { tool: 'gobuster', priority: 'high', params: 'dir -w common.txt' },
                { tool: 'nuclei', priority: 'medium', params: '-severity medium,high' },
                { tool: 'subfinder', priority: 'medium', params: '-silent' }
            ],
            'government': [
                { tool: 'subfinder', priority: 'high', params: '-passive' },
                { tool: 'nmap', priority: 'low', params: '-sS -T2' },
                { tool: 'nuclei', priority: 'low', params: '-severity info' }
            ],
            'financial': [
                { tool: 'nmap', priority: 'low', params: '-sS -T1' },
                { tool: 'sslscan', priority: 'high', params: '' },
                { tool: 'subfinder', priority: 'medium', params: '-passive' }
            ],
            'commercial': [
                { tool: 'nmap', priority: 'high', params: '-sV -sC' },
                { tool: 'gobuster', priority: 'high', params: 'dir -w big.txt' },
                { tool: 'nuclei', priority: 'high', params: '-severity critical,high,medium' },
                { tool: 'subfinder', priority: 'medium', params: '-all' },
                { tool: 'nikto', priority: 'medium', params: '' }
            ]
        };

        return toolSets[targetType] || toolSets['commercial'];
    }

    /**
     * Identify potential attack vectors
     * @param {string} target
     * @returns {Promise<Array>} Attack vectors
     */
    async identifyAttackVectors(target) {
        const targetType = this.classifyTarget(target);

        const attackVectors = {
            'educational': [
                'Web application vulnerabilities',
                'Exposed databases and services',
                'Social engineering via student/staff emails',
                'Legacy system exploitation'
            ],
            'government': [
                'Information disclosure through public records',
                'Social engineering via public contact information',
                'Third-party vendor vulnerabilities'
            ],
            'financial': [
                'SSL/TLS misconfigurations',
                'API endpoint vulnerabilities',
                'Social engineering via customer service'
            ],
            'commercial': [
                'Web application vulnerabilities',
                'Network service exploitation',
                'Social engineering',
                'Supply chain vulnerabilities',
                'Cloud misconfigurations'
            ]
        };

        return attackVectors[targetType] || attackVectors['commercial'];
    }

    /**
     * Prioritize scans based on intelligence
     * @param {string} target
     * @returns {Promise<Array>} Prioritized scan order
     */
    async prioritizeScans(target) {
        const tools = await this.selectTools(target);
        const riskAssessment = await this.assessRisk(target);

        // Sort by priority and risk level
        return tools
            .sort((a, b) => {
                const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                return priorityOrder[b.priority] - priorityOrder[a.priority];
            })
            .map((tool, index) => ({
                order: index + 1,
                ...tool,
                reasoning: this.getToolReasoning(tool.tool, target)
            }));
    }

    /**
     * Get reasoning for tool selection
     * @param {string} toolName
     * @param {string} target
     * @returns {string} Reasoning
     */
    getToolReasoning(toolName, target) {
        const reasoning = {
            'nmap': 'Essential for discovering open ports and services',
            'gobuster': 'Effective for finding hidden directories and files',
            'nuclei': 'Comprehensive vulnerability scanner with latest templates',
            'subfinder': 'Passive subdomain enumeration for attack surface mapping',
            'nikto': 'Web server vulnerability scanner',
            'sslscan': 'SSL/TLS configuration analysis'
        };

        return reasoning[toolName] || 'Standard security assessment tool';
    }

    /**
     * Analyze scan results using PentestGPT intelligence
     * @param {Object} scanResult
     * @param {string} toolUsed
     * @returns {Promise<Object>} Intelligent analysis
     */
    async analyzeScanResults(scanResult, toolUsed) {
        try {
            const analysis = {
                tool: toolUsed,
                timestamp: new Date().toISOString(),
                findings: this.extractFindings(scanResult, toolUsed),
                severity: this.assessSeverity(scanResult, toolUsed),
                recommendations: this.generateRecommendations(scanResult, toolUsed),
                nextSteps: this.suggestNextSteps(scanResult, toolUsed)
            };

            // Add to conversation history
            this.conversationHistory.push({
                type: 'scan_analysis',
                timestamp: new Date().toISOString(),
                data: analysis
            });

            return analysis;
        } catch (error) {
            console.error('‚ùå Scan result analysis failed:', error.message);
            throw error;
        }
    }

    /**
     * Extract key findings from scan results
     * @param {Object} scanResult
     * @param {string} toolUsed
     * @returns {Array} Key findings
     */
    extractFindings(scanResult, toolUsed) {
        // This would be enhanced with actual PentestGPT analysis
        const findings = [];

        if (scanResult.ports && scanResult.ports.length > 0) {
            findings.push(`Found ${scanResult.ports.length} open ports`);
        }

        if (scanResult.vulnerabilities && scanResult.vulnerabilities.length > 0) {
            findings.push(`Identified ${scanResult.vulnerabilities.length} potential vulnerabilities`);
        }

        if (scanResult.directories && scanResult.directories.length > 0) {
            findings.push(`Discovered ${scanResult.directories.length} accessible directories`);
        }

        return findings;
    }

    /**
     * Assess severity of findings
     * @param {Object} scanResult
     * @param {string} toolUsed
     * @returns {Object} Severity assessment
     */
    assessSeverity(scanResult, toolUsed) {
        let score = 0;
        let level = 'low';

        // Simple scoring algorithm (would be enhanced with ML)
        if (scanResult.vulnerabilities) {
            score += scanResult.vulnerabilities.length * 2;
        }

        if (scanResult.ports && scanResult.ports.length > 10) {
            score += 3;
        }

        if (score >= 8) level = 'critical';
        else if (score >= 6) level = 'high';
        else if (score >= 4) level = 'medium';

        return { score, level };
    }

    /**
     * Generate recommendations based on findings
     * @param {Object} scanResult
     * @param {string} toolUsed
     * @returns {Array} Recommendations
     */
    generateRecommendations(scanResult, toolUsed) {
        const recommendations = [];

        if (scanResult.ports && scanResult.ports.length > 0) {
            recommendations.push('Review open ports and disable unnecessary services');
        }

        if (scanResult.vulnerabilities && scanResult.vulnerabilities.length > 0) {
            recommendations.push('Prioritize patching identified vulnerabilities');
        }

        return recommendations;
    }

    /**
     * Suggest next steps for the penetration test
     * @param {Object} scanResult
     * @param {string} toolUsed
     * @returns {Array} Next steps
     */
    suggestNextSteps(scanResult, toolUsed) {
        const nextSteps = [];

        if (toolUsed === 'nmap' && scanResult.ports) {
            nextSteps.push('Run service-specific scans on discovered ports');
            nextSteps.push('Perform banner grabbing for version information');
        }

        if (toolUsed === 'gobuster' && scanResult.directories) {
            nextSteps.push('Investigate discovered directories for sensitive files');
            nextSteps.push('Run Nikto on interesting directories');
        }

        return nextSteps;
    }

    /**
     * Get conversation summary for reporting
     * @returns {Object} Conversation summary
     */
    getConversationSummary() {
        return {
            totalInteractions: this.conversationHistory.length,
            targetsAnalyzed: this.conversationHistory.filter(h => h.type === 'target_analysis').length,
            scansPerformed: this.conversationHistory.filter(h => h.type === 'scan_analysis').length,
            lastActivity: this.conversationHistory.length > 0 ?
                this.conversationHistory[this.conversationHistory.length - 1].timestamp : null
        };
    }

    /**
     * Save conversation to file for persistence
     * @param {string} sessionId
     */
    async saveConversation(sessionId) {
        try {
            const filename = `pentestgpt_session_${sessionId}_${Date.now()}.json`;
            const filepath = path.join(this.config.logDir, filename);

            const conversationData = {
                sessionId,
                timestamp: new Date().toISOString(),
                config: this.config,
                history: this.conversationHistory,
                summary: this.getConversationSummary()
            };

            fs.writeFileSync(filepath, JSON.stringify(conversationData, null, 2));
            console.log(`üíæ Conversation saved: ${filepath}`);

            return filepath;
        } catch (error) {
            console.error('‚ùå Failed to save conversation:', error.message);
            throw error;
        }
    }

    /**
     * Load conversation from file
     * @param {string} filepath
     */
    async loadConversation(filepath) {
        try {
            const data = JSON.parse(fs.readFileSync(filepath, 'utf8'));
            this.conversationHistory = data.history || [];
            this.taskLog = data.taskLog || {};

            console.log(`üìÅ Conversation loaded: ${filepath}`);
            return data;
        } catch (error) {
            console.error('‚ùå Failed to load conversation:', error.message);
            throw error;
        }
    }
}

module.exports = PentestGPTIntegration;